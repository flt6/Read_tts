# This file is rebuilt from https://github.com/skygongque/tts
import requests
import websockets
from log import Log
import asyncio
from datetime import datetime
import re
import uuid
import consts


def getLogger(show=True, debug=False):
    global logger
    logger = Log(name="TTS", show=show, debug=debug).get_logger()

# Generate X-Timestamp all correctly formatted
def getXTime():
    # Fix the time to match Americanisms
    hr_cr = lambda hr: str((hr - 1) % 24)
    # Add zeros in the right places i.e 22:1:5 -> 22:01:05
    fr = lambda x: ":".join(["%02d" % int(i) for i in str(x).split(':')])

    now = datetime.now()
    n = [
        fr(now.year), fr(now.month), fr(now.day), fr(hr_cr(int(now.hour))),
        fr(now.minute), fr(now.second), str(now.microsecond)[:3]
    ]
    return "{}-{}-{}T{}:{}:{}.{}Z".format(*n)

# Async function for actually communicating with the websocket
async def transferMsTTSData(SSML_text, outputPath):
    endpoint1 = "https://azure.microsoft.com/en-gb/services/cognitive-services/text-to-speech/"
    r = requests.get(endpoint1)
    main_web_content = r.text
    # They hid the Auth key assignment for the websocket in the main body of the webpage....
    token_expr = re.compile('token: \"(.*?)\"', re.DOTALL)
    Auth_Token = re.findall(token_expr, main_web_content)[0]
    # req_id is generated by uuid.
    req_id = uuid.uuid4().hex.upper()
    logger.debug(f"req_id: {req_id}")
    endpoint2 = "wss://eastus.tts.speech.microsoft.com/cognitiveservices/websocket/v1?Authorization=" + \
        Auth_Token + "&X-ConnectionId=" + req_id
    async with websockets.connect(endpoint2) as websocket:
        payload_1 = '{"context":{"system":{"name":"SpeechSDK","version":"1.12.1-rc.1","build":"JavaScript","lang":"JavaScript","os":{"platform":"Browser/Linux x86_64","name":"Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0","version":"5.0 (X11)"}}}}'
        message_1 = 'Path : speech.config\r\nX-RequestId: ' + req_id + '\r\nX-Timestamp: ' + \
            getXTime() + '\r\nContent-Type: application/json\r\n\r\n' + payload_1
        await websocket.send(message_1)

        payload_2 = '{"synthesis":{"audio":{"metadataOptions":{"sentenceBoundaryEnabled":false,"wordBoundaryEnabled":false},"outputFormat":"audio-24khz-48kbitrate-mono-mp3"}}}'
        message_2 = 'Path : synthesis.context\r\nX-RequestId: ' + req_id + '\r\nX-Timestamp: ' + \
            getXTime() + '\r\nContent-Type: application/json\r\n\r\n' + payload_2
        await websocket.send(message_2)

        payload_3 = SSML_text
        message_3 = 'Path: ssml\r\nX-RequestId: ' + req_id + '\r\nX-Timestamp: ' + \
            getXTime() + '\r\nContent-Type: application/ssml+xml\r\n\r\n' + payload_3
        await websocket.send(message_3)

        # Checks for close connection message
        end_resp_pat = re.compile('Path:turn.end')
        audio_stream = b''
        logger.debug("Begin to download.")
        while(True):
            response = await websocket.recv()
            # Make sure the message isn't telling us to stop
            if (re.search(end_resp_pat, str(response)) == None):
                # Check if our response is text data or the audio bytes
                if type(response) == type(bytes()):
                    # Extract binary data
                    try:
                        start_ind = str(response).find('Path:audio')
                        audio_stream += response[start_ind-2:]
                    except:
                        pass
            else:
                break
        with open(f'{outputPath}.mp3', 'wb') as audio_out:
            audio_out.write(audio_stream)


async def mainSeq(SSML_text, outputPath):
    await transferMsTTSData(SSML_text, outputPath)

if __name__ == "__main__":
    getLogger(True,True)
    text="Test audio"
    SSML_text=consts.SSML_MODEL.format(text)
    output_path = "test"
    asyncio.get_event_loop().run_until_complete(mainSeq(SSML_text, output_path))
